use crate::traits::MarketEvent;
use crate::orderbook::OrderBook;
use crate::types::{Price, Size};
use std::collections::HashMap;
use std::time::{Duration, Instant};

/// Trading signal generated by a strategy
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Signal {
    /// Arbitrage opportunity detected
    Arbitrage {
        /// Exchange to buy from
        buy_exchange: String,
        /// Exchange to sell to
        sell_exchange: String,
        /// Symbol to trade
        symbol: String,
        /// Buy price
        buy_price: Price,
        /// Sell price
        sell_price: Price,
        /// Quantity to trade
        quantity: Size,
        /// Expected profit (excluding fees)
        expected_profit: Price,
    },
    /// Other custom signal
    Custom {
        name: String,
        data: HashMap<String, String>,
    },
}

/// Market state for a symbol
#[derive(Debug, Clone)]
pub struct MarketState {
    /// Symbol name
    pub symbol: String,
    /// Order book for this symbol
    pub order_book: OrderBook,
    /// Last update timestamp
    pub last_update: u64,
}

impl MarketState {
    pub fn new(symbol: String) -> Self {
        let order_book = OrderBook::new(symbol.clone());
        Self {
            symbol,
            order_book,
            last_update: 0,
        }
    }

    /// Update market state with a new event
    pub fn update(&mut self, event: &MarketEvent) {
        match event {
            MarketEvent::OrderBookSnapshot(snapshot) => {
                self.order_book.apply_snapshot(snapshot.clone());
                self.last_update = snapshot.timestamp;
            }
            MarketEvent::OrderBookDelta(delta) => {
                self.order_book.apply_delta(delta.clone());
                self.last_update = delta.timestamp;
            }
            MarketEvent::Trade { .. } => {
                // Trades don't directly affect order book
                // In a real implementation, you might track trade history
            }
        }
    }

    /// Get the best bid price
    pub fn best_bid(&self) -> Option<(Price, Size)> {
        self.order_book.best_bid()
    }

    /// Get the best ask price
    pub fn best_ask(&self) -> Option<(Price, Size)> {
        self.order_book.best_ask()
    }

    /// Get the spread
    pub fn spread(&self) -> Option<Price> {
        self.order_book.spread()
    }
}

/// Strategy engine that processes market events and generates trading signals
pub struct StrategyEngine<S> {
    /// The strategy implementation
    strategy: S,
    /// Market states for all symbols
    market_states: HashMap<String, MarketState>,
    /// Last signal generation time for each symbol
    last_signal_time: HashMap<String, Instant>,
    /// Minimum time between signals (debounce)
    signal_cooldown: Duration,
}

impl<S> StrategyEngine<S>
where
    S: Strategy,
{
    /// Create a new strategy engine
    pub fn new(strategy: S, signal_cooldown: Duration) -> Self {
        Self {
            strategy,
            market_states: HashMap::new(),
            last_signal_time: HashMap::new(),
            signal_cooldown,
        }
    }

    /// Process a Market event and potentially generate a signal
    pub fn process_event(&mut self, event: MarketEvent) -> Option<Signal> {
        // Update market state
        let symbol = match event {
            MarketEvent::OrderBookSnapshot(ref snapshot) => snapshot.symbol.clone(),
            MarketEvent::OrderBookDelta(ref delta) => delta.symbol.clone(),
            MarketEvent::Trade { ref symbol, .. } => symbol.clone(),
        };

        let market_state = self.market_states
            .entry(symbol.clone())
            .or_insert_with(|| MarketState::new(symbol.clone()));
        
        market_state.update(&event);

        // Check if we should generate a signal
        let now = Instant::now();
        let last_signal = self.last_signal_time.get(&symbol);
        
        // Apply debounce/cooldown
        if let Some(last_time) = last_signal {
            if now.duration_since(*last_time) < self.signal_cooldown {
                return None;
            }
        }

        // Generate signal using the strategy
        if let Some(signal) = self.strategy.generate_signal(market_state) {
            self.last_signal_time.insert(symbol.clone(), now);
            return Some(signal);
        }

        None
    }

    /// Get the market state for a symbol
    pub fn get_market_state(&self, symbol: &str) -> Option<&MarketState> {
        self.market_states.get(symbol)
    }

    /// Get all market states
    pub fn get_all_market_states(&self) -> &HashMap<String, MarketState> {
        &self.market_states
    }
}

/// Trait that all strategies must implement
pub trait Strategy {
    /// Generate a trading signal based on the current market state
    fn generate_signal(&mut self, market_state: &MarketState) -> Option<Signal>;
}

/// Trait for processing market events from a stream
pub trait MarketEventProcessor {
    /// Process a market event
    fn process_event(&mut self, event: MarketEvent) -> Option<Signal>;
}

/// Implementation of MarketEventProcessor for StrategyEngine
impl<S> MarketEventProcessor for StrategyEngine<S>
where
    S: Strategy,
{
    fn process_event(&mut self, event: MarketEvent) -> Option<Signal> {
        self.process_event(event)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::{Price, Size};
    use std::collections::HashMap;
    use std::time::Duration;

    struct MockStrategy {
        should_generate_signal: bool,
        signal_count: usize,
    }

    impl MockStrategy {
        fn new(should_generate_signal: bool) -> Self {
            Self {
                should_generate_signal,
                signal_count: 0,
            }
        }

        fn get_signal_count(&self) -> usize {
            self.signal_count
        }
    }

    impl Strategy for MockStrategy {
        fn generate_signal(&mut self, _market_state: &MarketState) -> Option<Signal> {
            if self.should_generate_signal {
                self.signal_count += 1;
                Some(Signal::Custom {
                    name: "test_signal".to_string(),
                    data: HashMap::new(),
                })
            } else {
                None
            }
        }
    }

    #[test]
    fn test_strategy_engine_signal_generation() {
        let strategy = MockStrategy::new(true);
        let mut engine = StrategyEngine::new(strategy, Duration::from_millis(100));
        
        // Create a market State
        let market_state = MarketState::new("BTCUSDT".to_string());
        
        // Create a mock order book snapshot
        let snapshot = crate::orderbook::OrderBookSnapshot::new(
            "BTCUSDT".to_string(),
            vec![
                crate::orderbook::OrderBookLevel::new(
                    Price::from_str("100.00").unwrap(),
                    Size::from_str("10.0").unwrap()
                )
            ],
            vec![
                crate::orderbook::OrderBookLevel::new(
                    Price::from_str("101.00").unwrap(),
                    Size::from_str("10.0").unwrap()
                )
            ],
            123456789,
        );
        
        let event = MarketEvent::OrderBookSnapshot(snapshot);
        
        // Process: event
        let signal = engine.process_event(event);
        
        // Check that a signal was generated
        assert!(signal.is_some());
        
        // Process: same event again immediately
        let signal2 = engine.process_event(event.clone());
        
        // Check that no signal was generated due to cooldown
        assert!(signal2.is_none());
        
        // Wait for cooldown to expire
        std::thread::sleep(Duration::from_millis(110));
        
        // Process: event again
        let signal3 = engine.process_event(event.clone());
        
        // Check that a signal was generated again
        assert!(signal3.is_some());
    }

    #[test]
    fn test_market_state_updates() {
        let market_state = MarketState::new("BTCUSDT".to_string());
        
        // Create a mock order book snapshot
        let snapshot = crate::orderbook::OrderBookSnapshot::new(
            "BTCUSDT".to_string(),
            vec![
                crate::orderbook::OrderBookLevel::new(
                    Price::from_str("100.00").unwrap(),
                    Size::from_str("10.0").unwrap()
                )
            ],
            vec![
                crate::orderbook::OrderBookLevel::new(
                    Price::from_str("101.00").unwrap(),
                    Size::from_str("10.0").unwrap()
                )
            ],
            123456789,
        );
        
        let event = MarketEvent::OrderBookSnapshot(snapshot);
        market_state.update(event);
        
        // Check that order book was updated
        assert_eq!(market_state.best_bid(), Some((Price::from_str("100.00").unwrap(), Size::from_str("10.0").unwrap())));
        assert_eq!(market_state.best_ask(), Some((Price::from_str("101.00").unwrap(), Size::from_str("10.0").unwrap())));
        assert_eq!(market_state.spread(), Some(Price::from_str("1.00").unwrap()));
        assert_eq!(market_state.last_update, 123456789);
    }
}
